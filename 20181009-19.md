# SRE 本 輪読会 #11

今回のテーマはロードバランシングの話

単一障害点に依存する戦略はとらない、なぜなら大規模なシステムでは一点にすべてを依存するの破壊への処方箋である。  
具体的には以下2点について詳細をみていく

- データセンター間でのユーザートラフィックのバランスのとり方
- データセンター内でのロードバランシングの実装


## 19章　フロントエンドにおけるロードバランシング

### 19.1 パワーは解答にあらず

最高のマシンと障害を起こさないネットワークがあったとして物理的制約があるため、例え理想的な環境であっても単一障害点を持つインフラストラクチャに依存するのは悪い考え方である。

トラフィックのロードバランシングは、大量のマシンの中から特定のリクエストを処理するマシンを選択する方法のことです。  
最適な方法で分散処理されるのだが答えは一つでなく各要素に強く依存する。

- 問題を評価する階層レベル（地球か地域か）
- 問題を評価する技術的なレベル（ハードウェアかソフトウェアか）
- 扱うトラフィックの性質

ここで2つの例で掘り下げる

1. 基本的な検索リクエスト
2. ビデオのアップロードリクエスト

##### 基本的な検索リクエスト
ユーザーは検索の結果を早く受け取りたいので、検索のリクエストの場合に最も重要な変数はレイテンシである。

具体的には・・・

レイテンシを最小化したいため、できる限り近くにあるデータセンターに送られる。距離はラウンドトリップタイム ( RTT )で測られます

##### ビデオのアップロードリクエスト
ユーザーは処理に時間がかかることを認識していて、一度で処理を成功させてほしいと思うので最も重要な変数はスループットである。

具体的には・・・

レイテンシを犠牲にしてもスループットを最大化するために、その時点で利用度の低いリンクが使われることになる。


地球規模の例をあげてあるが、地域のレベルである一つのデータセンター内ではマシンへの距離は等しいとみなす。  
なので、負荷を分散されるにあたって重要視するのは、リソースの利用状況の最適化と、単一のサーバーが過負荷にならないようにすることです。

単純化された構図を例としてだしたが、最適な負荷分散に際してもっと多くの要素が考慮される。

例えば・・・

- リクエストによってはキャッシュの状態を更新しておくためにやや遠くのデータセンターに転送されるもケース
- インタラクティブではないトラフィックは、ネットワークの[輻湊](https://ja.wikipedia.org/wiki/%E8%BC%BB%E8%BC%B3)を避けるために完全に別のリージョンにルーティングされることもある

ロードバランシングは単純でも静的なものではない。  
次項以降で TCP を通じて送信される HTTP リクエストについて考えてみる。

### 19.2 DNS を使ったロードバランシング

前提で HTTP リクエストを送信する前の段階でクライアントは DNS を使って IP アドレスをルックアップすることになる。    
ロードバランシングの最初のレイヤーを置くのに最適な場所で、これがいわゆる DNS ロードバランシングである。  
DNS のレスポンスとしてとして複数の A もしくは AAAA レコードを返し、クライアントに任意の IP アドレスを一つ選んでもらう。  
構造的にはシンプルだが複数の課題がある。

##### 1つ目の課題
クライアントの挙動を制御することはできずDNSを問い合わせた結果、返ってくる IP はランダムである。
なので、どのサーバーにアクセスさせるかはクライアントに委ねられている。

##### 2つ目の課題
クライアントは地理的に最も近いアドレスを判断できない。  
権威のDNSサーバーに[エニーキャストアドレス](https://www.infraexpert.com/study/ipv6z11.html)を使い、DNSのクエリが最も近いアドレスに流れることを利用すれば軽減することは可能。  
すべてのネットワークとそのおおよその物理的な位置の対応表を構築し、その表に基づいてDNSのレスポンスを返すことも可能。  
[Geo Routing](https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/routing-policy.html) のことかな？

DNSの仲介役の存在によって、トラフィック管理についてきわめて重要な3つの影響が生じます。

##### IPアドレスが再帰的に解決されること

DNS応答による最適化はリゾルバと権威DNSサーバーとの区間に対してしか機能しない。  
解決策として、EDNS0拡張を使う方法がある。EDNS0拡張では、再帰的なリゾルバが送信するDNSクエリにクライアントのサブネットに関する情報が含まれる。なのでユーザーの視点からみて最適なレスポンスを返すことができる。

※EDNS0 ( Extension Mechanisms for DNS )
公式な標準にはなっていないが、利点が多いため最大級のDNSリゾルバであるOpenDNSやGoogleではサポートしている

```
DNSプロトコルを定義するRFC1035は、UDPメッセージは512バイト以下と規定していた。
しかしIPv4に加えてIPv6も使われるようになると、どうしてもリザルトの容量が多くなり、もって512 バイトに収まりきらないことが増えてきた。
この対策として作られたのが、EDNS0である。
```

##### 返答の経路が非決定的になること
階層構造でドメインが管理され無数にあるDNSサーバーの最適経路を管理はできない

[DNSについて](https://www.nic.ad.jp/ja/newsletter/No22/080.html)

##### キャッシュが追加されることによる複雑化

リゾルバはDNS問い合わせで帰ってきた結果をTTLに指定された期限内でキャッシュする。
なので、権威DNSサーバーからレスポンスが届くのが、一人のユーザーだけかもしれず、あるいは数千人のユーザーになるのかもしれない。


RFC1035に512バイトの制限に収まらないといけないので、一つのDNSレスポンス内に収めることのできるアドレス数には上限ができる。フロントエンドのロードバランシングの問題を解決するには、DNSでのロードバランシングだけでなく仮想IPアドレスを利用した処理が必要。


### 19.3 仮想IPアドレスでのロードバランシング

仮想IPアドレス ( VIP ) は、特定のネットワークインターフェイスに割り当てられるものではない。  
VIP は多くのデバイスで共有される。しかしユーザーから見れば VIP は通常の単一のIPアドレスに見える。  
利点として VIP の背後にあるマシンは隠蔽化されるため、ユーザーに気づかれずにアップグレードやマシンの追加メンテナンスがやりやすい。

VIP の実装で最も重要な部分はネットワークロードバランサーと呼ばれるデバイスで、VIPの背後に置かれたマシンのいずれかにフォワードする。

リクエストの送信先のバックエンドの決定に際しては、バランサーはいくつかのアプローチを取れるが、一番良いのは最も負荷の低いバックエンドを常に選択することです。ただしこのロジックはステートフルなプロトコルの場合はすぐに破綻してしまう。なぜならステートフルなプロトコルでは、一つのリクエストの期間の間、同じバックエンドが使われなければならない。ロードバランサーは自身を経由するすべての接続を追跡し、パケットが適切なバックエンドに送られることを保証しなければならない。

すべての接続の状態をメモリ内で追跡する必要がなく、しかも1つのマシンがダウンしてもすべての接続をリセットせずにすむ他の解決策が存在する。

[コンシステントハッシュ法](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%B3%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E6%B3%95) は、リストへの新しいバックエンドの追加や、リストからのバックエンドの削除が行われた場合でも比較的安定したままになるマッピングアルゴリズムを提供する方法。

データリンク層（OSI参照モデルレイヤー2）の情報を変更する方法もある。フォワードするパケットの送信先のMACアドレスを変更することによってバランサーは上位レイヤーの情報をそのままにしておくことができるので、バックエンドはオリジナルの送信元と送信先のIPアドレスを受信できる。この手法を[ダイレクトサーバーレスポンス](https://www.infraexpert.com/study/loadbalancer12.html) という。デメリットとして、すべてのマシンがお互いにデータリンク層で到達可能でなければならない。
Google ではこの方式は破綻している。

現在のVIPロードバランシングのソリューションは、パケットのカプセル化を使って[VIPのロードバランシング](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/44824.pdf)を実現している。  ネットワークロードバランサーはフォワードされたパケットを[汎用ルーティングカプセル化( Generic Routing Encapsulation = GRE )]
(https://tools.ietf.org/html/rfc1702) を使って別のIPパケットに格納し、バックエンドのアドレスを送信先として使います。デメリットとしてはパケットサイズが大きく（IPv4+GREなら24バイト）なってしまう。
